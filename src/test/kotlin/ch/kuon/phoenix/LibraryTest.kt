/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ch.kuon.phoenix

import kotlin.test.*
import org.json.JSONObject
import net.jodah.concurrentunit.Waiter

val url = "ws://localhost:4444/socket"

class ChannelTest {

    @Test fun testURL() {
        val sd = Socket(url)

        assertEquals(
            "ws://localhost:4444/socket/websocket?vsn=2.0.0",
            sd.endPointURL().toString(),
            "URL do not match"
        )
    }

    @Test fun testConnect() {
        val waiter = Waiter()

        val sd = Socket(url)

        sd.onOpen {
            waiter.resume()
        }
        sd.onError {
            waiter.fail("Socket error")
        }
        sd.connect()

        waiter.await(10000)

        sd.onClose { code, _ ->
            waiter.assertEquals(code, 1000)
            waiter.resume()
        }
        sd.disconnect()
        waiter.await(10000)
    }

    @Test fun testJoinError() {
        val waiter = Waiter()

        val sd = Socket(url)
        sd.connect()

        val chan = sd.channel(
            "mock:lobby"
        )

        chan
        .join()
        .receive("ok") { _ ->
            waiter.fail("Channel should fail join without auth")
        }
        .receive("error") { _ ->
            waiter.resume()
        }
        waiter.await(10000)
        sd.disconnect()
    }

    @Test fun testEcho() {
        val waiter = Waiter()

        val sd = Socket(url)
        sd.connect()

        val chan = sd.channel(
            "mock:lobby",
            JSONObject(hashMapOf("auth" to "secret"))
        )

        val obj = JSONObject(
            hashMapOf(
                "data1" to "payload1",
                "data2" to "payload2",
                "data3" to hashMapOf(
                    "data4" to "payload3",
                    "data5" to "payload4",
                    "data6" to listOf(
                        "a1", "a2", "a3"
                    )
                )
            )
        )

        chan
        .join()
        .receive("ok") { msg ->
            waiter.assertEquals("mockdata", msg.getString("mock"))
            waiter.resume()
        }
        .receive("error") { _ ->
            waiter.fail("Cannot join channel")
        }
        waiter.await(10000)

        chan
        .push("echo", obj)
        .receive("ok") { msg ->
            waiter.assertTrue(obj.similar(msg))
            waiter.resume()
        }
        waiter.await(10000)
        sd.disconnect()
    }

    @Test fun testBroadcast() {
        val waiter = Waiter()

        val sd1 = Socket(url)
        val sd2 = Socket(url)
        val sd3 = Socket(url)
        sd1.connect()
        sd2.connect()
        sd3.connect()

        val auth = JSONObject(hashMapOf("auth" to "secret"))
        val chan1 = sd1.channel("mock:lobby", auth)
        val chan2 = sd2.channel("mock:lobby", auth)
        val chan3 = sd3.channel("mock:lobby", auth)

        chan1
        .join()
        .receive("ok") { _ ->
            waiter.resume()
        }

        chan2
        .join()
        .receive("ok") { _ ->
            waiter.resume()
        }

        chan3
        .join()
        .receive("ok") { _ ->
            waiter.resume()
        }

        waiter.await(10000, 3)

        chan1.on("broadcast") { msg ->
            waiter.assertEquals("br-data", msg.response.getString("br"))
            waiter.resume()
        }

        chan2.on("broadcast") { msg ->
            waiter.assertEquals("br-data", msg.response.getString("br"))
            waiter.resume()
        }

        chan3.on("broadcast") { msg ->
            waiter.assertEquals("br-data", msg.response.getString("br"))
            waiter.resume()
        }

        chan3.push("trigger", JSONObject(hashMapOf("br" to "br-data")))

        waiter.await(10000, 3)
        sd1.disconnect()
        sd2.disconnect()
        sd3.disconnect()
    }

    @Test fun testPresence() {
        val waiterOnJoin1 = Waiter()
        val waiterOnJoin2 = Waiter()
        val waiterOnLeave1 = Waiter()
        val waiterOnLeave2 = Waiter()
        val waiterOnSync1 = Waiter()
        val waiterOnSync2 = Waiter()
        val sd1 = Socket(url)
        val sd2 = Socket(url)

        sd1.connect()
        sd2.connect()

        val ch1 = sd1.channel("mock:presence")
        val ch2 = sd2.channel("mock:presence")


        val pr1 = Presence(ch1)
        val pr2 = Presence(ch2)

        pr1.onJoin { _, _, _ ->
            waiterOnJoin1.resume()
        }
        pr1.onLeave { _, _, _ ->
            waiterOnLeave1.resume()
        }
        pr1.onSync {
            waiterOnSync1.resume()
        }
        pr2.onJoin { _, _, _ ->
            waiterOnJoin2.resume()
        }
        pr2.onLeave { _, _, _ ->
            waiterOnLeave2.resume()
        }
        pr2.onSync {
            waiterOnSync2.resume()
        }

        waiterOnJoin1.assertEquals(listOf<String>(), pr1.list())
        waiterOnJoin1.assertEquals(listOf<String>(), pr2.list())

        ch1.join()
        waiterOnJoin1.await(10000, 1)
        waiterOnSync1.await(10000, 2)

        ch2.join()
        waiterOnJoin2.await(10000, 1)
        waiterOnSync2.await(10000, 2)

        waiterOnJoin1.await(10000, 1)
        waiterOnSync1.await(10000, 1)

        ch2.leave()
        waiterOnLeave1.await(10000, 1)

        sd2.disconnect()
        sd1.disconnect()
    }

}
